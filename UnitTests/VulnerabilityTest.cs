using NUnit.Framework;
using SafeVault.Security;
using System.Data; // For DataTable
using System.Data.SqlClient; // For SqlException
using Moq; // For mocking database dependencies, install via NuGet: Install-Package Moq

namespace SafeVault.Tests
{
    [TestFixture]
    public class TestInputValidationAndSqlInjection
    {
        // Mocking SqlConnection and SqlCommand is complex with ADO.NET directly.
        // For demonstration, we'll mock the UserRepository to simulate database responses
        // without needing a live DB connection in unit tests,
        // or provide a simplified in-memory "db" for integration-like tests.
        // A full integration test would require a test database.

        private const string TEST_CONNECTION_STRING = "Server=localhost;Database=SafeVaultDB;Integrated Security=True;";
        private UserRepository _userRepository;

        [OneTimeSetUp]
        public void Setup()
        {
            // For actual testing, replace with a real test connection string or mock completely.
            // For this example, we'll initialize with a dummy string, assuming
            // UserRepository's GetUserByUsername gracefully handles DB errors.
            // A more realistic test would use a localdb or in-memory DB for UserRepository.
            _userRepository = new UserRepository(TEST_CONNECTION_STRING);

            // Optional: Populate a test user to ensure `GetUserByUsername` works.
            // In a real test setup, you'd manage this with a clean database for each test run.
            // If running against a real SQL Server, ensure the DB and table exist.
            // _userRepository.AddUser("testuser", "test@example.com", "password123!");
            // _userRepository.AddUser("adminuser", "admin@example.com", "adminpass");
        }

        [Test]
        public void TestSanitizeHtml_RemovesScriptTags()
        {
            string maliciousInput = "<script>alert('xss');</script>Username";
            string sanitizedOutput = InputSanitizer.SanitizeHtml(maliciousInput);
            Console.WriteLine($"Original: {maliciousInput}");
            Console.WriteLine($"Sanitized: {sanitizedOutput}");
            Assert.That(sanitizedOutput, Does.Not.Contain("<script>"));
            Assert.That(sanitizedOutput, Does.Not.Contain("alert('xss');"));
            Assert.That(sanitizedOutput, Is.EqualTo("&lt;script&gt;alert(&#39;xss&#39;);&lt;/script&gt;Username"));
        }

        [Test]
        public void TestSanitizeHtml_RemovesJavascriptProtocol()
        {
            string maliciousInput = "<a href=\"javascript:alert('xss')\">Click Me</a>";
            string sanitizedOutput = InputSanitizer.SanitizeHtml(maliciousInput);
            Console.WriteLine($"Original: {maliciousInput}");
            Console.WriteLine($"Sanitized: {sanitizedOutput}");
            Assert.That(sanitizedOutput, Does.Not.Contain("javascript:"));
            Assert.That(sanitizedOutput, Is.EqualTo("&lt;a href=&quot;alert(&#39;xss&#39;)&quot;&gt;Click Me&lt;/a&gt;")); // 'javascript:' part is removed
        }

        [Test]
        public void TestSanitizeHtml_EncodesHtmlCharacters()
        {
            string inputWithHtml = "<h1>Hello & World</h1>";
            string sanitizedOutput = InputSanitizer.SanitizeHtml(inputWithHtml);
            Console.WriteLine($"Original: {inputWithHtml}");
            Console.WriteLine($"Sanitized: {sanitizedOutput}");
            Assert.That(sanitizedOutput, Is.EqualTo("&lt;h1&gt;Hello &amp; World&lt;/h1&gt;"));
        }

        [Test]
        public void TestIsValidEmail_ValidEmail()
        {
            Assert.IsTrue(InputSanitizer.IsValidEmail("test@example.com"));
            Assert.IsTrue(InputSanitizer.IsValidEmail("john.doe123@sub.domain.co.uk"));
        }

        [Test]
        public void TestIsValidEmail_InvalidEmail()
        {
            Assert.IsFalse(InputSanitizer.IsValidEmail("invalid-email"));
            Assert.IsFalse(InputSanitizer.IsValidEmail("test@.com"));
            Assert.IsFalse(InputSanitizer.IsValidEmail("test@example"));
            Assert.IsFalse(InputSanitizer.IsValidEmail(""));
            Assert.IsFalse(InputSanitizer.IsValidEmail(null));
        }

        [Test]
        public void TestIsValidUsername_ValidUsername()
        {
            Assert.IsTrue(InputSanitizer.IsValidUsername("user123"));
            Assert.IsTrue(InputSanitizer.IsValidUsername("john-doe"));
            Assert.IsTrue(InputSanitizer.IsValidUsername("Admin_User"));
        }

        [Test]
        public void TestIsValidUsername_InvalidUsername()
        {
            Assert.IsFalse(InputSanitizer.IsValidUsername("us")); // Too short
            Assert.IsFalse(InputSanitizer.IsValidUsername("user with spaces")); // Contains spaces
            Assert.IsFalse(InputSanitizer.IsValidUsername("user@!#")); // Contains special characters
            Assert.IsFalse(InputSanitizer.IsValidUsername(""));
            Assert.IsFalse(InputSanitizer.IsValidUsername(null));
        }

        [Test]
        public void TestParameterizedQuery_PreventsSqlInjection()
        {
            // This test needs to simulate a database query using the UserRepository.
            // Due to the nature of unit testing and real DB connections, we'll illustrate
            // the expected behavior if the UserRepository is correctly implemented with parameters.

            // Scenario 1: Malicious SQL in username (should NOT execute as SQL)
            string maliciousUsername = "' OR 1=1 --";
            // If the query was vulnerable: SELECT * FROM Users WHERE Username = '' OR 1=1 --'
            // This would return all users.
            // With parameterization, it correctly searches for a username literal "' OR 1=1 --".
            DataTable result = _userRepository.GetUserByUsername(maliciousUsername);

            // Assert that no user is found for the malicious username,
            // or if a mock is used, assert that the parameter was correctly passed.
            Assert.That(result, Is.Not.Null); // Ensure no database error occurred
            Assert.That(result.Rows.Count, Is.EqualTo(0)); // No user named "' OR 1=1 --" should exist

            // Scenario 2: Standard valid username
            string validUsername = "testuser"; // Assuming this user might exist in your test DB
            DataTable validResult = _userRepository.GetUserByUsername(validUsername);

            // If "testuser" exists, it should return 1 row. If not, 0.
            // The key is that it doesn't throw a SQL error due to injection.
            Assert.That(validResult, Is.Not.Null);
            // If you have a test user 'testuser' added, you'd expect:
            // Assert.That(validResult.Rows.Count, Is.EqualTo(1));
            // Assert.That(validResult.Rows[0]["Username"].ToString(), Is.EqualTo(validUsername));
            // Otherwise, it correctly finds 0 rows, demonstrating no injection occurred.
        }
    }
}
